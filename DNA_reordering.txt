// Class to describe DNA
// Borrowed from 'Evolution EcoSystem'
// by Daniel Shiffman <http://www.shiffman.net> #codingrainbow

// Settings apply equally to all cells in a strain
// Adding genes for position. All cells in a strain will share the same start position

class DNA {

  float[] genes;  // 'genes' is an array of float values in the range (0-1)
  int numGenes;

  // Constructor (makes a random DNA)
  DNA() {
      numGenes = 34;
      genes = new float[numGenes];  // DNA contains an array called 'genes' with [32] float values

      // DNA gene mapping (29 genes)
	  // 0=ID

// 1=fill_H_start
// 2=fill_H_end
// 3=fill_S_start
// 4=fill_S_end
// 5=fill_B_start
// 6=fill_B_end
// 7=fill_A_start
// 8=fill_A_end

// 9=stroke_H_start
// 10=stroke_H_end
// 11=stroke_S_start
// 12=stroke_S_end
// 13=stroke_B_start
// 14=stroke_B_end
// 15=stroke_A_start
// 16=stroke_A_end

// 17=radius_Start
// 18=radius_End

// 19=flatness_start
// 20=flatness_end

// 21=twist_Start
// 22=twist_End

// 23=noisePercent_Start
// 24=noisePercent_End

// 25=noise_vMax
// 26=noise_Step
// 27=noise_xOff
// 28=noise_yOff

// 29=fertility
// 30=spawnLimit
// 31=lifespan

// 32=StripeSize
// 33=StripeRatio

	  
	  
	  
	  
	  // 28 = Strain id
	  
      // 0 = fill Hue (0-360)
	  // 20 = fill_Hend
      // 1 = fill Saturation (0-255)
	  // 21 = fill_Send
      // 2 = fill Brightness (0-255)
	  // 22 = fill_Bend
      // 3 = fill Alpha (0-255)
	  // 23 = fill_Aend
      
      // 4 = stroke Hue (0-360)
	  // 24 = stroke_Hend
      // 5 = stroke Saturation (0-255)
	  // 25 = stroke_Send
      // 6 = stroke Brightness (0-255)
	  // 26 = stroke_Bend
      // 7 = stroke Alpha (0-255)
	  // 27 = stroke_Aend
      
      // 8 = cellStartSize (10-50) (cellendipity/one uses 0-200)
      // 9 = cellEndSize (5 - 20 %) (cellendipity/one uses 0-50)
      
      // 11 = flatness START (50-200 
	  NEW     flatness END
	  
      // 12 = spiral screw START (-75 - +75 %)
	  NEW     spiral screw END
      
      // 17 = noisePercent START (0-100%)
	  NEW     noisePercent END
	  
      // 15 = vMax (Noise) (0-5) (cellendipity/one uses 0-4)
      // 16 = step (Noise) (1 - 6 * 0.001?)  (cellendipity/one uses 0.001-0.006) 
      // 18 = xOff (rnd 1000)
      // 19 = yOff (rnd 1000)
 
	  // 13 = fertility (70-90%)
      // 14 = spawnCount (1-5)
	  // 10 = lifespan (200-1000)
 
      // 29 = StripeSize // Should this just be a function of radius? (like nucleus) No, there would still need to be a factor, so can just as well specify exact value.
      // 30 = StripeRatio

      // RANDOMIZED VALUES
            genes[0] = random(360); // 0 = fill Hue (0-360)
            //genes[0] = 230; // 0 = fill Hue (0=RED)
            //genes[0] = gs.bkg_H; // 0 = fill Hue 
            //genes[0] = (gs.bkg_H + random(170, 210)) % 360; // 0 = fill Hue (0-360)
            //genes[0] = (gs.bkg_H + 240) % 360; // 0 = fill Hue (0-360)
            //genes[0] = (gs.bkg_H + 0) % 360; // 0 = fill Hue (0-360)
            //genes[1] = random(130,180); // 1 = fill Saturation (0-255)
            genes[1] = 255; // 1 = fill Saturation (0-255) LAST:50
			      //genes[1] = gs.bkg_S; // 1 = fill Saturation (0-255)
            //genes[2] = gs.bkg_B;    // 2 = fill Brightness (0-255)
            genes[2] = 64;    // 2 = fill Brightness (0-255)
            genes[3] = 255;   // 3 = fill Alpha (0-255)

            //genes[20] = (gs.bkg_H + 10) % 360;  // 20 = fill_Hend
            //genes[20] = gs.bkg_H * random (0.85, 0.97);  // 20 = fill_Hend
            //genes[20] = gs.bkg_H;
            genes[20] = genes[0];
            //genes[20] = 300;
            
            //genes[21] = gs.bkg_S; // fill_Send
            //genes[21] = gs.bkg_S * random(0.5, 0.9);// fill_Send
            genes[21] = 128;// fill_Send LAST: 128, 220
            
            //genes[22] = gs.bkg_B * 0.5;// fillBstart
            //genes[22] = gs.bkg_B * random(0.9, 1.1);// fillBend
            genes[22] = 200;// fill_Bend last: 180

            genes[23] = 255;// fill_Aend

            //genes[4] = random(360);    // 4 = stroke Hue (0-360)
            //genes[4] = gs.bkg_H;  // stroke_Hstart
            genes[4] = 0;  // stroke_Hstart
            genes[5] = 0;    // 5 = stroke Saturation (0-255)
            //genes[5] = gs.bkg_S;  // stroke_Sstart
            genes[6] = 0;    // 6 = stroke Brightness (0-255) 0 = BLACK
            //genes[6] = 0;  // stroke_Bstart
            //genes[7] = random(5.5, 16.3);    // 7 = stroke Alpha (0-255)
            genes[7] = 0;  // strokeAstart
            
            //genes[24] = gs.bkg_H;  // stroke_Hend
            genes[24] = 0;  // stroke_Hend            
            genes[25] = 0;  // stroke_Send
            genes[26] = 128;  // stroke_Bend
            genes[27] = 0;  // strokeAend
      
            //genes[8] = width/((gs.rows)*random(2, 4));   // 8 = cellStartSize (10-50) (cellendipity/one uses 0-200)
            genes[8] = width * 0.001 * random(75, 200);
            //genes[8] = width * 0.001 * random(25, 50);
            //genes[8] = width/((gs.rows)*2);
            //genes[9] = random(15, 30);   // 9 = cellEndSize (5 - 20 %) (cellendipity/one uses 0-50)
            genes[9] = 5;
            genes[10] = width * 0.001 * random(200, 500);  // 10 = lifespan (200-1000)
            //genes[10] = width * 0.001 * 300; //
            //genes[10] = 20;
            //genes[11] = random (100, 120); // 11 = flatness (50-200 %)
            genes[11] = 300;
            //genes[12] = random(0, 30);  // 12 = spiral screw (-75 - +75 %)
            genes[12] = 0;
            
            //genes[13] = random(65,85);  // 13 = fertility (70-90%)
			      genes[13] = 65;
            //genes[14] = random(2,3);   // 14 = spawnCount (1-5)
            genes[14] = 1;
            
            genes[15] = random(2, 4);      // 15 = vMax (Noise) (0-5) (cellendipity/one uses 0-4)
            //genes[15] = 2.8731356;
            genes[16] = random(1, 6);   // 16 = step (Noise) (1 - 6 * 0.001?)  (cellendipity/one uses 0.001-0.006)
            //genes[16] = 4.848875;
            //genes[17] = random(60,100);  // 17 = noisePercent (0-100%)
            genes[17] = 0; // 17 = noisePercent (0-100%)
            
            genes[18] = random(1000); // 18 = xOff (rnd 1000)
            genes[19] = random(1000); // 19 = yOff (rnd 1000)
            
            //genes[18] = 648.2952; // 18 = xOff (rnd 1000)
            //genes[19] = 728.6432; // 19 = yOff (rnd 1000)
            
            genes[28] = 0;  // strain ID
            
            //if (random(1)>0.4) {genes[29] = random(20,50);} else {genes[29] = 10000;} // StripeSize
            //genes[29] = 100;
            //genes[29] = 30;
            genes[29] = random(20,60);
            genes[30] = 0.50;  // StripeRatio
            //genes[30] = random(0.4, 0.8);  // StripeRatio



            logDNA();
   }

  void logDNA() {
    for (int n = 0; n < numGenes; n++) {
      output.println("gene[" + n + "] = " + genes[n]);
      }
  }

  DNA(float[] newgenes) {
    genes = newgenes;
  }

  DNA combine(DNA otherDNA_) { // Returns a new set of DNA consisting of randomly selected genes from both parents
    float[] newgenes = new float[genes.length];
    for (int i = 0; i < newgenes.length; i++) {
      if (random(1) < 0.5) {newgenes[i] = genes[i];}
      else {newgenes[i] = otherDNA_.genes[i];} // 50/50 chance of copying gene from either 'mother' or 'other'
    }
    return new DNA(newgenes);
  }

}